---
  html_document:
    toc: true
    highlight: zenburn
    theme: united
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(tidy=TRUE, highlight=TRUE, dev="png",
               cache=TRUE, highlight=TRUE, autodep=TRUE, warning=FALSE,
               error=FALSE, message=FALSE, prompt=TRUE, comment='', fig.cap='')
```
## Overview
This is an analysis looking at the pilot plate samples; there are 24 samples of
what should be rods that were selected via sorting for ds-red. Half of these
samples are from a library prep using a quarter of the materials, the other
half are those same samples prepared using the full materials, for comparison
and to save on reagents.

The 12 samples are split evenly between rescued and non-rescued rods, and we'd
like to look at differences between those if possible.

We also want to compare these pilot plate samples to the SMART-seq samples and make
some determinations about which prep method worked better.

```{r qc-setup}
base_dir = "/Users/rory/cache/wu-retina-singlecell/pilot-plate/"
library(ggplot2)
library(reshape)
library(gplots)
library(edgeR)
library(CHBUtils)
library(pheatmap)
project_summary = paste(base_dir, "project-summary.csv", sep="")
counts_file = paste(base_dir, "combined.counts", sep="")
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
"#0072B2", "#D55E00", "#CC79A7")
summarydata = data.frame(read.table(project_summary, header=TRUE, sep=","),
row.names="Name", check.rows=FALSE)
summarydata$Name = rownames(summarydata)
summarydata = summarydata[order(summarydata$Name),]
counts = read.table(counts_file, header=TRUE, row.names="id", check.names=FALSE)
counts = counts[, order(colnames(counts))]
cnames = unlist(lapply(colnames(counts), function(x) strsplit(x, ".", fixed=TRUE)[[1]][1]))
colnames(counts) = cnames
# this is a list of all non user-supplied metadata columns that could appear
known_columns = c("Name", "X.GC", "Exonic.Rate",
              "Sequences.flagged.as.poor.quality", "rRNA.rate",
              "Fragment.Length.Mean", "Intronic.Rate",
              "Intergenic.Rate", "Mapping.Rate", "Quality.format",
              "Duplication.Rate.of.Mapped", "Mapped", "rRNA",
              "Sequence.length", "Transcripts.Detected",
              "Mean.Per.Base.Cov.", "Genes.Detected",
              "Unique.Starts.Per.Read", "unique_starts_per_read",
              "complexity", "X5.3.bias")
summarydata$ds.red.z = (summarydata$ds.red - mean(summarydata$ds.red)) / sd(summarydata$ds.red)
summarydata$wrow = substring(summarydata$well, 1, 1)
summarydata$wcol = substring(summarydata$well, 2, 2)
summarydata$Genes.Detected = colSums(counts > 0)
full = subset(summarydata, conc == "Full")
full_counts = counts[, colnames(counts) %in% full$Name]
full_counts = full_counts[rowSums(full_counts > 0) > 2,]
```

```{r heatmap-function}
get_heatmap_fn = function(summarydata) {
    # return the pheatmap function with or without metadata
    metadata = summarydata[, !colnames(summarydata) %in% known_columns, drop=FALSE]
    if(ncol(metadata) == 0) {
       return(pheatmap)
    }
    else {
    # rownames(metadata) = summarydata$Name
    heatmap_fn = function(data, ...) {
        pheatmap(data, annotation=metadata, ...)
    }
    return(heatmap_fn)
}}
heatmap_fn = get_heatmap_fn(summarydata)
```

First we'll try correlating the samples using the raw counts; this is a heatmap
of Pearson correlations between the samples. The samples seem to mostly cluster
by plate/rescued status.

```{r heatmap-annotations}
pheatmap(cor(full_counts), annotation=summarydata[, c("rescued", "plate", "ds.red",
   "ds.red.z", "well", "wrow", "wcol")])
```

The overall correlation between the samples is really low; and the rescued
cells are more variable than the non-rescued cells.

Clustering on the normalized counts has a similar pattern.

```{r correlation-normalized}
y = DGEList(counts=full_counts)
y = calcNormFactors(y)
normalized_counts = cpm(y, normalized.lib.sizes=TRUE)
pheatmap(cor(normalized_counts), annotation=summarydata[, c("rescued", "plate", "Mapped", "ds.red.z")])
```

Spearman instead of Pearson correlation correlates based on the rank and is
less sensitive to genes with large expression values. The Spearman correlation
isn't very good either.

```{r correlation-normalized-spearman}
y = DGEList(counts=full_counts)
y = calcNormFactors(y)
normalized_counts = cpm(y, normalized.lib.sizes=TRUE)
pheatmap(cor(normalized_counts, method="spearman"),
         annotation=summarydata[, c("rescued", "plate", "Mapped", "ds.red.z")])
```

There has been some papers looking at other methods. One is using a proportion
correlation metric:
http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004075

This makes all of the correlatons look bad.

```{r correlation-propcor}

propcor = function(x, y) {
    x = log(x + 0.1)
    y = log(y + 0.1)
    num = 2 * cov(x, y)
    denom = var(x) + var(y)
return(num/denom)}

do_propcor = function(x) {
     foo = list()
     for(i in seq_len(ncol(x))) {
         for(j in seq_len(ncol(x))) {
        x2 = x[, i]
        y2 = x[, j]
        foo = c(foo, propcor(x2, y2)) } }
    foo = unlist(foo)
    foo = matrix(foo, ncol(x), ncol(x))
    colnames(foo) = colnames(x)
    rownames(foo) = colnames(x)
    return(foo)}

z = do_propcor(full_counts)
pheatmap(z, annotation=summarydata[, c("rescued", "plate", "Mapped", "ds.red.z")])
```

This clusters the cells differently, just thought
I'd try it to see what it looked like since I had just read the paper.

The low correlation is likely partially caused by the excess of
zero counts in the data. The SCDE package has some alternative methods to
try to fix this. We'll try one of them here.

```{r scde-clustering}
library(scde)
o.ifm = scde.error.models(counts=full_counts, groups=full$rescued,
        save.crossfit.plots=F, n.cores=1, threshold.segmentation=T,
        save.model.plots=F, verbose=0)
valid.cells <- o.ifm$corr.a >0;
o.ifm = o.ifm[valid.cells,]
valid_counts = full_counts[, valid.cells]
valid_summary = subset(full, rownames(full) %in% colnames(valid_counts))
p.self.fail <- scde.failure.probability(models=o.ifm,counts=valid_counts)
n.simulations <- 100; k <- 0.9;
cell.names <- colnames(valid_counts); names(cell.names) <- cell.names;
cd = valid_counts
n.cores = 1
dl <- mclapply(1:n.simulations,function(i) {
  scd1 <- do.call(cbind,lapply(cell.names,function(nam) {
    x <- cd[,nam];
    # replace predicted drop outs with NAs
    x[!as.logical(rbinom(length(x),1,1-p.self.fail[,nam]*k))] <- NA;
    x;
    }))
  rownames(scd1) <- rownames(cd);
  # calculate correlation on the complete observation pairs
  cor(log10(scd1+1),use="pairwise.complete.obs");
},mc.cores=n.cores)

direct.dist <- Reduce("+",dl)/length(dl)
pheatmap(direct.dist, annotation=valid_summary[, c("rescued", "plate",
                                                   "Mapped")])
```

These don't look much better though.


# Quality control metrics

## Mapped reads
```{r mapped-plot}
ggplot(summarydata, aes(x=Name, y=Mapped)) +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    geom_bar(stat="identity") +
    ylab("mapped reads") + xlab("")
```

## Genomic mapping rate
```{r mapping-rate-plot}
ggplot(summarydata, aes(x=Name, y=Mapping.Rate)) +
    geom_bar(stat="identity") +
    ylab("mapping rate") + xlab("") +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90))
```

## Number of genes detected
```{r genes-detected-plot}
dd = data.frame(Name=names(counts), Genes.Detected = colSums(counts > 0))
ggplot(dd, aes(x=Name, y=Genes.Detected)) +
    geom_bar(stat="identity") +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    ylab("genes detected") + xlab("")
```

## Gene detection saturation
```{r saturation-plot}
dd = data.frame(Mapped=summarydata$Mapped, Genes.Detected = colSums(counts > 0))
ggplot(dd, aes(x=Mapped, y=Genes.Detected)) +
    geom_point() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    ylab("genes detected") + xlab("reads mapped")
```

## Exonic mapping rate
```{r exonic-mapping-plot}
ggplot(summarydata, aes(x=Name, y=Exonic.Rate)) +
    geom_bar(stat="identity") +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    ylab("exonic mapping rate") + xlab("")
```

## rRNA mapping rate
```{r rRNA-rate-plot}
ggplot(summarydata, aes(x=Name, y=rRNA.rate)) +
    geom_bar(stat="identity") +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    ylab("rRNA rate") + xlab("")
```

## Boxplot of log10 counts per gene
```{r boxplot-raw}
melted = melt(counts)
colnames(melted) = c("sample", "count")
melted$sample = factor(melted$sample)
melted$count = log(melted$count)
ggplot(melted, aes(x=sample, y=count)) + geom_boxplot() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + xlab("")
```

## Boxplot of log10 TMM-normalized counts per gene
Trimmed mean of M-values (TMM) normalization is described
[here](http://genomebiology.com/2010/11/3/R25)

Robinson, M. D., & Oshlack, A. (2010). A scaling normalization method for differential expression analysis of RNA-seq data. Genome Biology, 11(3). doi:10.1186/gb-2010-11-3-r25

```{r boxplot-normalized}
y = DGEList(counts=counts)
y = calcNormFactors(y)
normalized_counts = cpm(y, normalized.lib.sizes=TRUE)
melted = melt(normalized_counts)
colnames(melted) = c("gene", "sample", "count")
melted$sample = factor(melted$sample)
melted$count = log(melted$count)
ggplot(melted, aes(x=sample, y=count)) + geom_boxplot() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + xlab("")
```

## Density of log10 TMM-normalized counts
```{r density-normalized}
ggplot(melted, aes(x=count, group=sample)) +
    geom_density() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + xlab("")
```

## What types of RNA was sequenced?

```{r rna-biotype-density}
library(biomaRt)
melted = melt(log(normalized_counts))
colnames(melted) = c("gene", "sample", "count")
mart = useMart("ensembl", dataset="mmusculus_gene_ensembl")
bm = getBM(mart=mart, attributes=c("ensembl_gene_id", "transcript_biotype"))
idx = match(melted$gene, bm$ensembl_gene_id)
melted$biotype = bm[idx, 2]
ggplot(melted[is.numeric(melted$count),], aes(x=count, group=sample)) +
  geom_density(adjust=1) + facet_wrap(~biotype) +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + xlab("")
```

```{r scde-analysis}
library(scde)
o.ifm = scde.error.models(counts=full_counts, groups=full$rescued,
        save.crossfit.plots=F, n.cores=1, threshold.segmentation=T,
        save.model.plots=F, verbose=0)
valid.cells <- o.ifm$corr.a >0;
o.ifm = o.ifm[valid.cells,]
valid_counts = full_counts[, valid.cells]
valid_summary = subset(full, rownames(full) %in% colnames(valid_counts))
o.prior <- scde.expression.prior(models=o.ifm,counts=valid_counts, length.out=400,show.plot=T)
ediff = scde.expression.difference(o.ifm, valid_counts, o.prior,
                                   groups=valid_summary$rescued,
                                   n.randomizations=100, n.cores=1, verbose=0)
ediff$pvalue = pnorm(-(abs(ediff$Z))) * 2
ediff$padj = p.adjust(ediff$pvalue)
ediff = ediff[order(ediff$pvalue),]
```

We still can't find anything significantly different.

## rod-cone housekeeping genes
```{r cone-rod-housekeeping-genes}
rod = c("Rho","Sag","Pdc","Gnat1","Pde6g","Rom1","Gngt1","Unc119",
        "Gnb1","Gcap1","Guca1a","Pde6b","Guca2a","Prph2","Aipl1",
        "Tulp1","Rs1","Rcvrn","Cngb1")
roska_cone = c("Pde6c","Opn1sw","Fabp7","Gnat2","Opn1mw","Pde6h","Clca3",
              "Clca3","Clca3","Agr2","Arr3","Gulo","Otop3","Ppm1j","Mogat1","Mogat1",
              "Osgep","Ppp1r14d","Cngb3","Igj","1700113O17Rik","Gngt2","En2","Rbp3",
              "Rbp3","Lcn2","Acbd6")
rod = c(rod, "Pde6b","Nr2e3","Cnga1","Pde6a","A930006D01Rik","Rp1","Cyld",
             "Sh2d1a","Guca1b","Faim","Gm12689","Gm12689","Gnb1","Fscn2",
             "Reep6","Nxnl2","Nxnl1","Nrl","Gm13251","Gm13251","1700020D05Rik",
             "Spata1","Olfr772","Slc24a1","Ybx3","Gm9958","Gm9958","Rex2",
             "Rexo2","Ppap2c","Hmgb2")
melted = melt(log(normalized_counts))
colnames(melted) = c("gene", "sample", "count")
mart = useMart("ensembl", dataset="mmusculus_gene_ensembl")
bm = getBM(mart=mart, attributes=c("ensembl_gene_id", "mgi_symbol"))
bm$id = bm$ensembl_gene_id
bm$ensembl_gene_id = NULL

symbols = data.frame(normalized_counts)
symbols$id = rownames(normalized_counts)
library(dplyr)
symbols = symbols %>% left_join(bm, by="id")
```

There is more rod expression than cone expression in the pilot data:

```{r rod-expression}
rod_vals = subset(symbols, mgi_symbol %in% rod)
rownames(rod_vals) = rod_vals$mgi_symbol
rod_vals$mgi_symbol = NULL
rod_vals$id = NULL
rod_vals = log(rod_vals + 1)
colnames(rod_vals) = colnames(normalized_counts)
pheatmap(rod_vals, annotation=summarydata[, c("rescued", "plate", "Mapped", "Genes.Detected")], fontsize=6, main="rod genes")
```


```{r cone-expression}
cone_vals = subset(symbols, mgi_symbol %in% roska_cone)
rownames(cone_vals) = cone_vals$mgi_symbol
cone_vals$mgi_symbol = NULL
cone_vals$id = NULL
cone_vals = log(cone_vals + 1)
colnames(cone_vals) = colnames(normalized_counts)
pheatmap(cone_vals, annotation=summarydata[, c("rescued", "plate", "Mapped", "ds.red.z")], fontsize=6, main="cone genes")
```

There looks to be some genes which might be cones by accident; we can see that
P2-1B and P1-2E have less rod expressed genes than the other cells. P1-3G as
well. All of the rescued cells are missing Sag and Gnat1 and those are expressed
highly in the non-rescued cells.

P1-3G looks like a cone, as it is expressing pretty low for the rod genes and
high for the cone genes. We can maybe filter out some of the rod and cone
genes, as markers since it looks like some of them might be wrong. Nxn1,
Guaca1b and Guaca1a

For the two outliers for ds-red expression, both are on the rescued plate, but
one clusters with the non-rescued cells.

# ds-red distribution
ds-red mesaurements varied over a couple orders of magnitude. This
didn't seem to be a particularly useful metric in terms of classifying the
samples.
```{r ds-red distribution}
ggplot(summarydata, aes("ds.red", ds.red)) + geom_point() + scale_y_log10() +
     xlab("") + ylab("ds-red expression") +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90))
```

## clustering by the second set of rod-cone genes

```{r load-type-annotations}
types_fn = "/Users/rory/cache/wu-retina-singlecell/metadata/gene_types.tsv"
types = read.table(types_fn, header=TRUE, stringsAsFactors=FALSE)
types = types[!duplicated(types$id),]
rownames(types) = types$id
types$type = as.factor(types$type)
```
Some annotations are duplicated, so drop them.

```{r duplicated-types}
mart = useMart("ensembl", dataset="mmusculus_gene_ensembl")
bm = getBM(mart=mart, attributes=c("ensembl_gene_id", "mgi_symbol"))
bm$id = bm$ensembl_gene_id
bm$ensembl_gene_id = NULL
m = merge(types, bm, by="id")
m = m[order(m$type),]
all_types = m
cone_rod = subset(all_types, type %in% c("cone_specific_or_enriched", "novel_cone_1",
                                     "novel_cone_2", "rod_enriched", "rod_specific"))
cbPalette <- colorRampPalette(c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7"))
```

Now look at their expression:

```{r heatmap-types}
lcounts = data.frame(log(normalized_counts + 1))
colnames(lcounts) = colnames(counts)
ann_colors = list(type=cbPalette(nlevels(all_types$type)))
names(ann_colors[[1]]) <- levels(all_types$type)
anno_df = data.frame(type=all_types$type)
rownames(anno_df) = all_types$id
pheatmap(lcounts[all_types$id,], fontsize=6, annotation_row=anno_df,
         cluster_rows=FALSE, show_rownames=FALSE, annotation_colors=ann_colors,
         annotation=summarydata[, c("rescued", "plate", "Mapped", "ds.red.z")])
ggsave("heatmap-all.pdf")
cone_rod_counts = lcounts[cone_rod$id,]
rownames(cone_rod_counts) = cone_rod[match(rownames(cone_rod_counts), cone_rod$id), "mgi_symbol"]
anno_df = data.frame(type=all_types$type)
rownames(anno_df) = all_types$mgi_symbol
pheatmap(cone_rod_counts, fontsize=6, annotation_row=anno_df,,
         cluster_rows=FALSE, annotation_colors=ann_colors,
         annotation=summarydata[, c("rescued", "plate", "Mapped", "ds.red.z")])
ggsave("heatmap-cone-rod-only.pdf")
```

Most of the cells seem to be enriched for the rod markers. Cells P1_3G looks
like it might be two cells, a cone and a rod. P2_1B doens't really look
like any of the cell types and P1_2E looks like it might be a cone.

Drop those cells so we are left with just rods. The trouble is that although the
cells cluster by rescued and plate, in the rescued cells it looks like there is
much less expression of rod genes even though there is a similar overall mapping
rate for most of the samples. Does this mean these are not rods? Does rescuing them
do something else to them?

```{r drop-non-rods}
drop_cols = grepl("P1-3G", colnames(lcounts))
drop_cols = drop_cols | grepl("P2-1B", colnames(lcounts))
drop_cols = drop_cols | grepl("P1-2E", colnames(lcounts))

rod_counts = lcounts[,!drop_cols]
ann_colors = list(type=cbPalette(nlevels(types$type)))
names(ann_colors[[1]]) <- levels(types$type)

pheatmap(rod_counts[rownames(types),], fontsize=6, annotation_row=types,
         cluster_rows=FALSE, show_rownames=FALSE,
         annotation_colors=ann_colors,
         annotation=summarydata[, c("rescued", "plate", "Mapped", "ds.red.z")])
ggsave("heatmap-rods.pdf")
```

Now go ahead and do SCDE differential expression on just the rods.

## differential expression of just rods rescue
```{r scde-analysis-rods}
rod_raw = counts[, !drop_cols]
rod_raw = rod_raw[, !grepl("quarter", colnames(rod_raw))]
rod_raw = rod_raw[rowSums(rod_raw) > 0,]
rod_summary = summarydata[colnames(rod_raw),]

library(scde)
o.ifm = scde.error.models(counts=rod_raw, groups=rod_summary$rescued,
        save.crossfit.plots=F, n.cores=1, threshold.segmentation=T,
        save.model.plots=F, verbose=0)
valid.cells <- o.ifm$corr.a >0;
o.ifm = o.ifm[valid.cells,]
valid_counts = rod_raw[, valid.cells]
valid_summary = subset(rod_summary, rownames(rod_summary) %in% colnames(valid_counts))
o.prior <- scde.expression.prior(models=o.ifm,counts=valid_counts, length.out=400,show.plot=T)
ediff = scde.expression.difference(o.ifm, valid_counts, o.prior,
                                   groups=valid_summary$rescued,
                                   n.randomizations=100, n.cores=1, verbose=0)
ediff$pvalue = pnorm(-(abs(ediff$Z))) * 2
ediff$padj = p.adjust(ediff$pvalue)
ediff = ediff[order(ediff$pvalue),]
```

There isn't anything differentially expressed that survives the multiple
hypothesis testing correction, but we can look at the top 50 that have
a gene symbol by p-value at least and write that out to a table for later.

```{r top-100}
library(biomaRt)
mouse = useMart("ensembl", dataset="mmusculus_gene_ensembl")
symbols = getBM(mart=mouse, attributes=c("ensembl_gene_id", "mgi_symbol"))
ediff$symbol = symbols[match(rownames(ediff), symbols$ensembl_gene_id), "mgi_symbol"]
top_100 = head(ediff, 100)

write.table(top_100, "pilot-plate-rod-only-rescue.tsv", col.names=TRUE, row.names=TRUE,
            quote=FALSE, sep="\t")
```

## revisiting the smart-seq data
With these gene lists we can take another look and see if the cells cluster
by subtype at all.

```{r smartseq-data}
smartseq_fn = "/Users/rory/cache/wu-retina-singlecell/05-2015-smartseq/combined.counts"
smartseq_summary_fn = "/Users/rory/cache/wu-retina-singlecell/05-2015-smartseq/project-summary.csv"
smartseq_summary = read.table(smartseq_summary_fn, header=TRUE, sep=",")
smartseq_summary$Name = gsub("-", "_", smartseq_summary$Name, fixed=TRUE)
rownames(smartseq_summary) = smartseq_summary$Name
smartseq = read.table(smartseq_fn, header=TRUE, row.names="id")
cnames = colnames(smartseq)
cnames = gsub(".counts", "", cnames)
cnames = gsub("X", "", cnames)
cnames = gsub(".", "_", cnames, fixed=TRUE)
colnames(smartseq) = cnames
smartseq = smartseq[, order(colnames(smartseq))]
smartseq_summary = smartseq_summary[order(rownames(smartseq_summary)),]
smartseq_summary$Genes.Detected = colSums(smartseq > 0)
smartseq_summary$HDAC4 = unlist(c(smartseq["ENSMUSG00000026313",]))
smartseq_summary$HDAC4 = log(smartseq_summary$HDAC4 + 1)
smartseq_dge = DGEList(counts=smartseq)
smartseq_dge = calcNormFactors(smartseq_dge)
smartseq_normalized = cpm(smartseq_dge, normalized.lib.sizes=TRUE)
lsmartseq = log(smartseq_normalized + 1)
anno_df = data.frame(type=all_types$type)
rownames(anno_df) = all_types$id
pheatmap(lsmartseq[rownames(types),], fontsize=6, annotation_row=anno_df,
         annotation_colors=ann_colors,
         cluster_rows=FALSE, show_rownames=FALSE, show_colnames=FALSE,
         annotation=smartseq_summary[, c("location_info", "rescue", "Mapped",
                                         "Genes.Detected", "HDAC4")])
ggsave("heatmap-smartseq.pdf")
```

It looks like there is a set of cells on the left that express markers for
cones and rods, as well as a set of cells that look like glia and a set of
cells that don't really express any of these markers. There isn't any clustering
by HDAC4 expression as well.

In your email you pointed out the set of cells on the left might be cones due to
the Opn1mw expression. It doesn't
look like there is any clear clustering of those cells by any location info or
rescue status though, as we can see below:

```{r smartseq-cone-rod-only}
cone_rod_smartseq = lsmartseq[cone_rod$id,]
colnames(cone_rod_smartseq) = cnames
rownames(cone_rod_smartseq) = cone_rod[match(rownames(cone_rod_smartseq), cone_rod$id), "mgi_symbol"]
anno_df = data.frame(type=all_types$type)
rownames(anno_df) = all_types$mgi_symbol
pheatmap(cone_rod_smartseq, fontsize=6, annotation_row=anno_df,,
         cluster_rows=FALSE, annotation_colors=ann_colors,
         annotation=smartseq_summary[, c("location_info", "rescue", "Mapped")])
ggsave("heatmap-smartseq-cone-rod-only.pdf")
```

## revisiting the scrb-seq data
I thought that maybe using these marker genes we could see some
clustering in the SCRB-seq data, but it doesn't look like it. I'm not
sure what to make of the SCRB-seq data, it looks like Rho is expressed in
all of the cells but Opn1mw also looks like it is expressed in some of
the cells. It would be interesting to see what you think about this. The
expression pattern almost looks artifactual. I didn't do anything with
this data other than take the UMI counts that the Broad generated.

```{r scrbseq-data}
scrbseq_fn = "/Users/rory/cache/wu-retina-singlecell/counts/scrb-trimarchi/Cepko_Trimarchi_buffer.all.refseq.umi.dat"
scrbseq = read.table(scrbseq_fn, header=TRUE)
scrbseq_dge = DGEList(counts=scrbseq)
scrbseq_dge = calcNormFactors(scrbseq_dge)
scrbseq_normalized = cpm(scrbseq_dge, normalized.lib.sizes=TRUE)
lscrbseq = log(scrbseq_normalized + 1)
anno_df = data.frame(type=all_types$type)
rownames(anno_df) = all_types$mgi_symbol
lscrbseq = subset(lscrbseq, rownames(lscrbseq) %in% rownames(anno_df))
anno_df = subset(anno_df, rownames(anno_df) %in% rownames(lscrbseq))
pheatmap(lscrbseq[rownames(anno_df),], fontsize=6, annotation_row=anno_df,
         annotation_colors=ann_colors,
         cluster_rows=FALSE, show_rownames=FALSE, show_colnames=FALSE)
ggsave("heatmap-scrbseq.pdf")
scrbseq_cone_rod = subset(cone_rod, cone_rod$mgi_symbol %in% rownames(lscrbseq))
cone_rod_scrbseq = lscrbseq[scrbseq_cone_rod$mgi_symbol,]
anno_df = data.frame(type=all_types$type)
rownames(anno_df) = all_types$mgi_symbol
pheatmap(cone_rod_scrbseq, fontsize=6, annotation_row=anno_df,,
         cluster_rows=FALSE, annotation_colors=ann_colors, show_colnames=FALSE)
ggsave("heatmap-scrbseq-cone-rod-only.pdf")
```

## what do dropseq counts look like?

I was pretty impressed with the DropSeq paper; I think that might be the hot new
thing. It is cheap, they gave plans to fab the device to do it and sequencing
40,000 cells lets you do a lot more with the data. So far I'm a big DropSeq fan.

I was curious to compare it to SCRB-seq to see how it does.

```{r dropseq}
dropseq_fn = "/Users/rory/cache/wu-retina-singlecell/drop-seq/GSM1626793_P14Retina_1.digital_expression.txt"
dropseq <- read.table(dropseq_fn, header=TRUE, row.names=1)

qplot(rowSums(dropseq)) +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + xlab("counts per gene") +
          scale_x_log10() + ylab("")
qplot(colSums(dropseq)) +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + xlab("counts per sample") +
    scale_x_log10() + ylab("")

qplot(colSums(dropseq > 0)) +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + xlab("genes detected per sample") +
    scale_x_log10() + ylab("")
```


For DropSeq each of these counts is an individual transcript. We detect a low number
of genes per sample, at low counts, similar to SCRB-seq. DropSeq is more efficient
in detecting transcripts, however:

```{r dropseq-vs-scrbseq}
df <- data.frame(reads=colSums(dropseq), detected=colSums(dropseq > 0))

ggplot(df, aes(reads, detected)) + geom_point() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90))

scrbseq_df <- data.frame(reads=colSums(scrbseq), detected=colSums(scrbseq > 0))

df$type <- "dropseq"
scrbseq_df$type <- "scrbseq"

all <- rbind(df, scrbseq_df)
ggplot(all, aes(reads, detected, color=type)) + geom_point() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90))
```

## what do the dropseq genes look like if we use our markers?
```{r dropseq-heatmap}
dropseq_symbols = strsplit(rownames(dropseq), ":")
dropseq_symbols = lapply(dropseq_symbols, function(x) x[3])
dropseq_symbols = unlist(dropseq_symbols)
dropseq_keep = dropseq_symbols %in% rownames(anno_df)
dropseq_cone_rod = dropseq[dropseq_keep,]
rownames(dropseq_cone_rod) = dropseq_symbols[dropseq_keep]
dropseq_cone_rod = log(dropseq_cone_rod + 1)
dropseq_cone_rod = dropseq_cone_rod[rowSums(dropseq_cone_rod) > 0,]
anno_keep = rownames(anno_df)[rownames(anno_df) %in% rownames(dropseq_cone_rod)]
dropseq_cone_rod = dropseq_cone_rod[anno_keep,]
pheatmap(dropseq_cone_rod, fontsize=4, annotation_row=anno_df,
         cluster_rows=FALSE, annotation_colors=ann_colors, show_colnames=FALSE)
```

That looks pretty nice. It kind of looks similar to the SCRB-seq data, where
a small number of genes are expressed in all of the rods. Hm.

I'm kind of rethinking what I thought before about SCRB-seq; maybe it is possible to do it, but you just need a couple of orders of magnitude more cells than we've
been looking at. In the Drop-Seq paper they sequenced 45k cells, and were able
to suss out the major cell types in the retina with 1,000 cells. Maybe if we can
do on the order of tens of thousands of cells, we can pick out some
subpopulations.

One thing to note is that in the DropSeq paper, they picked the top 1/3 cells
with the most number of counts to build the classifier. If we did that with just
this 6k cell sample we took, that means the cutoff for genes detected would be
somewhere around 1,000 genes, a pretty low amount.

## DropSeq markers for rods

I went into the DropSeq paper and pulled out the set of genes that were
identified as the classifier for rods and made heatmaps of those for the
datasets:

the SMART-seq data:

```{r dropseq-rod-smartseq}
dropseq_rod_up_human <- c("CARTPT","MAF","PPP1R17","GPR22","GNG2","NR4A2","IGFBP5",
                          "GRIK1","SLC4A4","SNED1","CAMK4","KCND3","C1QL1","ID4",
                          "GRIA3","LGR5","PCP4L1","DNER","NFIA", "IGFN1")
dropseq_rod_down_human <- c("HBA-A1","HBB-BS","PCDH17","CHN2","SLC6A1","ELAVL2",
                            "PCDH10","CBLN2","TKT","TAC2","HPGD","MGP","MEIS2",
                            "GABRA1","SHISA9","CALD1","UNC13C","RBP1","QPCT","PTGDS")
mouse = useMart("ensembl", dataset="mmusculus_gene_ensembl")
human = useMart("ensembl", dataset="hsapiens_gene_ensembl")
conversions = getLDS(attributes=c("entrezgene", "ensembl_gene_id",
                                  "mgi_symbol"),
                     attributesL=c("entrezgene", "ensembl_gene_id",
                                   "hgnc_symbol"), mart=mouse, martL=human)

dropseq_rod_up <- conversions[match(dropseq_rod_up_human, conversions$HGNC.symbol),
                              "MGI.symbol"]
dropseq_rod_up_id <- conversions[match(dropseq_rod_up_human, conversions$HGNC.symbol),
                              "Ensembl.Gene.ID"]
dropseq_rod_down_id <- conversions[match(dropseq_rod_down_human,
                                         conversions$HGNC.symbol), "Ensembl.Gene.ID"]
dropseq_rod_up <- dropseq_rod_up[!is.na(dropseq_rod_up)]
dropseq_rod_down <- conversions[match(dropseq_rod_down_human, conversions$HGNC.symbol),
                                "MGI.symbol"]
dropseq_rod_down <- dropseq_rod_down[!is.na(dropseq_rod_down)]

dropseq_rod <- c(dropseq_rod_up, dropseq_rod_down)
dropseq_rod_id <-  c(dropseq_rod_up_id, dropseq_rod_down_id)
dropseq_rod_id <- dropseq_rod_id[dropseq_rod_id %in% rownames(lsmartseq)]

smart_dropseq_rod <- lsmartseq[dropseq_rod_id,]
rownames(smart_dropseq_rod) = conversions[match(rownames(smart_dropseq_rod),
                                                conversions$Ensembl.Gene.ID),
                                                "MGI.symbol"]
pheatmap(smart_dropseq_rod, fontsize=6, annotation_row=anno_df,
         cluster_rows=FALSE, annotation_colors=ann_colors, show_colnames=FALSE)
```

SCRB-seq:
```{r dropseq-scrbseq-rod}
lscrbseq2 = log(scrbseq_normalized + 1)
scrbseq_dropseq_rod_idx = rownames(lscrbseq2) %in% dropseq_rod
scrbseq_dropseq_rod = lscrbseq2[scrbseq_dropseq_rod_idx,]
pheatmap(scrbseq_dropseq_rod, fontsize=6,
         cluster_rows=FALSE, annotation_colors=ann_colors, show_colnames=FALSE)
```

the pilot:
```{r dropseq-pilot-rod}
pilot_dropseq_rod <- lcounts[dropseq_rod_id,]
rownames(pilot_dropseq_rod) = conversions[match(rownames(pilot_dropseq_rod),
                                                conversions$Ensembl.Gene.ID),
                                                "MGI.symbol"]
pheatmap(pilot_dropseq_rod, fontsize=6, annotation_row=anno_df,,
         cluster_rows=FALSE, annotation_colors=ann_colors, show_colnames=TRUE,
         annotation=summarydata[, c("rescued", "plate", "Mapped", "ds.red.z")])
```

Here is the dropseq data for the same set of genes, it looks pretty sparse,
similar to the SCRB-seq data.

```{r dropseq-rods}
ids = unlist(lapply(rownames(dropseq), function(x) strsplit(x, ":")[[1]][3]))

use_dropseq = ids %in% dropseq_rod
ldropseq_rod = log(dropseq[use_dropseq,] + 1)
pheatmap(ldropseq_rod, fontsize=6, cluster_rows=FALSE)
```

## difference between the quarter and full samples
The Spearman and Pearson correlation for the quarter and full samples looks good.
Spearman:

```{r full-quarter-correlation-spearman}
groups <- summarydata %>% group_by(code, conc) %>% select(Name, code, conc)
full_name <- summarydata %>% filter(conc ==  "Full") %>% select(Name, code)
quarter_name <- summarydata %>% filter(conc ==  "Quarter") %>% select(Name, code)
cors <- list()
names <- list()
for(i in seq(nrow(full_name))) {
  names <- c(names, as.character(full_name$code[i]))
  cors <- c(cors, name=cor(lcounts[, full_name$Name[i]],
                           lcounts[, quarter_name$Name[i]], method="spearman"))
}
names <-  unlist(names)
cors <-  unlist(cors)
qplot(names, cors) +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + ylab("spearman correlation") +
          xlab("")
```

And Pearson:

```{r full-quarter-pearson-correlation}
cors <- list()
names <- list()
for(i in seq(nrow(full_name))) {
  names <- c(names, as.character(full_name$code[i]))
  cors <- c(cors, name=cor(lcounts[, full_name$Name[i]],
                           lcounts[, quarter_name$Name[i]]))
}
names <-  unlist(names)
cors <-  unlist(cors)
qplot(names, cors) +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + ylab("pearson correlation") +
    xlab("")
```

I think it is probably okay to use the quarter isolation method if you are going
to use that method, it seems to work okay.

## revisiting the SMARTseq data with Seurat
Seurat is a new single cell differential expression package for R. What is nice
about it is it has some clustering functions that are based off of t-SNE
clustering, which makes the nice plots in the DropSeq paper.

```{r serat}
smartseq_summary_fn = "/Users/rory/cache/wu-retina-singlecell/05-2015-smartseq/project-summary.csv"
smartseq_summary = read.table(smartseq_summary_fn, header=TRUE, sep=",")
smartseq_summary$Name = gsub("-", "_", smartseq_summary$Name)
rownames(smartseq_summary) = smartseq_summary$Name

library(Seurat)
nbd.data = data.frame(lsmartseq)
cnames = gsub(".counts", "", colnames(lsmartseq))
cnames = gsub("X", "", cnames)
cnames = gsub(".", "_", cnames, fixed=TRUE)
snames = cnames
cnames = gsub("_", ":", cnames, fixed=TRUE)
cnames = paste(smartseq_summary[snames,]$location_info, cnames, sep="_")
cnames = paste(smartseq_summary[snames,]$rescue, cnames, sep=":")
colnames(nbd.data) = cnames
nbt = new("seurat", raw.data=nbd.data)
nbt= setup(nbt, project="NBT", min.cells = 3, min.genes = 1000, is.expr=1,
           names.delim="_", names.field=1)
```

Below we identify highly variable genes and use those to do PCA on the samples.

```{r identify-variable-genes}
nbt = mean.var.plot(nbt, y.cutoff=2, x.low.cutoff=2, fxn.x=expMean,
                    fxn.y=logVarDivMean)
length(nbt@var.genes)
```

Below we calculate the weights for the first 10 components to pick out
the ones that explain most of the variance, then look at the separation along
those components. We can see components 1-6 are significant so we will use those.
We'll drop 7 because it is easier to look at pairs of components going forward.

```{r pca-jackstraw}
nbt = pca(nbt, do.print=FALSE)
nbt = jackStraw(nbt, num.replicate=200, do.print=FALSE)
jackStrawPlot(nbt, PCs=1:10)
```


Below we plot the (1, 2), (3, 4) and (5, 6) components along with a heatmap
of each separating the samples, then output list of the gene ids that have
the heightest weights for each component along with a heatmap of the expression
values.


Components (1, 2):
```{r pca-plot}
pca.plot(nbt, 1, 2, pt.size=2)
print.pca(nbt, 1:2)
viz.pca(nbt, 1:2)
pcHeatmap(nbt,pc.use = 1,do.balanced = FALSE)
pcHeatmap(nbt,pc.use = 2,do.balanced = FALSE)
```

Components (3, 4):
```{r pca-plot-3-4}
pca.plot(nbt, 3, 4, pt.size=2)
viz.pca(nbt, 3:4)
pcHeatmap(nbt,pc.use = 3, do.balanced = FALSE)
pcHeatmap(nbt,pc.use = 4, do.balanced = FALSE)
```

Components (5, 6):
```{r pca-plot-5-6}
pca.plot(nbt, 5, 6, pt.size=2)
viz.pca(nbt, 5:6)
pcHeatmap(nbt,pc.use = 5, do.balanced = FALSE)
pcHeatmap(nbt,pc.use = 6, do.balanced = FALSE)
```

Components (7, 8):
```{r pca-plot-7-8}
pca.plot(nbt, 7, 8, pt.size=2)
viz.pca(nbt, 7:8)
pcHeatmap(nbt, pc.use = 7, do.balanced = FALSE)
pcHeatmap(nbt, pc.use = 8, do.balanced = FALSE)
```

You can see that the principal components don't separate the cells by
the experimental setup very well. We can run the version of clustering in
Seurat called t-SNE, which tries to place the cells into separate groups.
Here there is maybe some kind of separation but it isn't great.

```{r tsne-run}
nbt=run_tsne(nbt, dims.use = 1:7, max_iter=2000)
```

If we plot the markers for each condition vs the principal component, with
the red dots having a higher weighting in that component than the yellow dots,
we can see that there isn't a clear separation as well.

```{r tsne-plot}
tsne.plot(nbt, pt.size = 4)

markers.all=find_all_markers(nbt, thresh.test = 3, test.use = "roc",
                             do.print = TRUE)
markers.all = markers.all[order(-markers.all$power),]

pcs.plot=paste("PC",1:8,sep="")
feature.heatmap(nbt,pcs.plot,cols.use = heat.colors(4), pt.size = 2)
```

## DESeq2 PCA plot
DESeq2 also has its own PCA method; it takes the top 500 most variable genes
and does PCA on them; we can also see no clear separation based on the experimental
setup.
```{r deseq2-pca}
cnames = gsub(".counts", "", colnames(smartseq))
cnames = gsub("X", "", cnames)
cnames = gsub(".", "_", cnames, fixed=TRUE)
colnames(smartseq) = cnames
keep_smartseq = smartseq_summary[rownames(smartseq_summary) %in% colnames(smartseq),]
smartseq = smartseq[, order(colnames(smartseq))]
keep_smartseq = keep_smartseq[order(rownames(keep_smartseq)),]
dds = DESeqDataSetFromMatrix(countData=smartseq, colData=keep_smartseq, design=~rescue)
vst = varianceStabilizingTransformation(dds)
plotPCA(vst, intgroup=c("rescue", "location_info"))
```

## smartseq heatmap using the Dropseq markers from the retina paper

```{r dropseq-markers}
dropseq_markers = read.table("/Users/rory/cache/wu-retina-singlecell/metadata/dropseq-marker.tsv", header=FALSE)
dropseq_marker_id = conversions[match(dropseq_markers$V1, conversions$MGI.symbol),]$Ensembl.Gene.ID
dropseq_marker_exp = lsmartseq[dropseq_marker_id,]
rownames(dropseq_marker_exp) = conversions[match(dropseq_marker_id,
   conversions$Ensembl.Gene.ID),]$MGI.symbol
pheatmap(dropseq_marker_exp)
```

## Was the pilot-plate worse than the smart-seq data?

It looks like the pilot-plate worked pretty well given that it only
had a small amount of reads in the FASTQ files, averaging around 300k. Here
is a plot of the SMART-seq vs the pilot plate experiment, looking at saturation,
with the points scaled for percentage of reads mapped. The pilot-plate data looks
pretty good, and you can can see many failed cells for the SMART-seq data.

```{r saturation-plot-both}
dd = data.frame(Mapped=summarydata$Mapped, Genes.Detected = colSums(counts > 0),
                plate="pilot", rate=summarydata$Mapping.Rate)
dd2 <- data.frame(Mapped=smartseq_summary$Mapped, Genes.Detected=colSums(smartseq > 0),
                  plate="smartseq", rate=smartseq_summary$Mapping.Rate)
saturation <- rbind(dd, dd2)
ggplot(saturation, aes(x=Mapped, y=Genes.Detected, color=plate, size=rate)) +
    geom_point() + scale_size(range=c(1,3)) +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    ylab("genes detected") + xlab("reads mapped") + scale_x_log10()
```

## Do the SMART-seq cells cluster by reads mapping to GFP?

Only a small set of the cells have GFP expression:

```{r gfp-reads}
smartseq_gfp = read.table("/Volumes/Clotho/Users/rory/cache/wu-retina-singlecell/05-2015-smartseq/gfp-reads/gfp_reads.counts", header=FALSE)
colnames(smartseq_gfp) = c("Name", "gfp")
smartseq_gfp$Name = gsub("-", "_", smartseq_gfp$Name)
smartseq_summary = merge(smartseq_summary, smartseq_gfp, by="Name")

ggplot(smartseq_summary, aes(Mapped, gfp)) +
    geom_point() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    scale_x_sqrt() +
    scale_y_sqrt()
```

```{r fix-smartseq-columns}
cnames = colnames(smartseq)
cnames = gsub(".counts", "", cnames)
cnames = gsub("X", "", cnames)
cnames = gsub(".", "_", cnames, fixed=TRUE)
colnames(smartseq) = cnames
cnames = colnames(smartseq_normalized)
cnames = gsub(".counts", "", cnames)
cnames = gsub("X", "", cnames)
cnames = gsub(".", "_", cnames, fixed=TRUE)
colnames(smartseq_normalized) = cnames
rownames(smartseq_summary) = smartseq_summary$Name
smartseq_summary$lgfp = log(smartseq_summary$gfp + 1)
```

Cells don't cluster by number of reads of GFP using Pearson correlation of the
TMM-normalized counts:

```{r cluster-smartseq-with-gfp}
pheatmap(cor(smartseq_normalized), annotation=smartseq_summary[, c("lgfp", "Mapped")])
```

Using the SCDE method of clustering which takes into account some of the
dropouts:

```{r calculate-smartseq-ifm}
library(scde)
smartseq = smartseq[,colSums(smartseq)>1e4];
smartseq = smartseq[rowSums(smartseq) > 0,]
o.ifm = scde.error.models(counts=smartseq,
        save.crossfit.plots=F, n.cores=1, threshold.segmentation=T,
        save.model.plots=F, verbose=0)
```

```{r calculate-distance-smartseq-scde}
valid.cells <- o.ifm$corr.a >0;
o.ifm = o.ifm[valid.cells,]
valid_counts = smartseq[, valid.cells]
valid_summary = subset(smartseq_summary, rownames(smartseq_summary) %in% colnames(valid_counts))
p.self.fail <- scde.failure.probability(models=o.ifm,counts=valid_counts)
n.simulations <- 100; k <- 0.9;
cell.names <- colnames(valid_counts); names(cell.names) <- cell.names;
cd = valid_counts
n.cores = 1
dl <- mclapply(1:n.simulations,function(i) {
  scd1 <- do.call(cbind,lapply(cell.names,function(nam) {
    x <- cd[,nam];
    # replace predicted drop outs with NAs
    x[!as.logical(rbinom(length(x),1,1-p.self.fail[,nam]*k))] <- NA;
    x;
    }))
  rownames(scd1) <- rownames(cd);
  # calculate correlation on the complete observation pairs
  cor(log10(scd1+1),use="pairwise.complete.obs");
},mc.cores=n.cores)
```

```{r heatmap-smartseq-scde}
direct.dist <- Reduce("+",dl)/length(dl)
direct.dist = direct.dist[, colSums(is.na(direct.dist)) > 0]
pheatmap(direct.dist, annotation=valid_summary[, c("rescue", "location_info",
                                                   "Mapped", "lgfp")],
         fontsize=6)
```

Neither of these really look like they are clustering by any of the metadata.

Looking at just the cone and rod markers, the number of GFP reads seems to
somewhat be associated with the cells that express a lot of the marker genes in
general. I'm not really sure what to make of that though.

## adding location info and rescue to the SMARTseq cone-rod heatmap
You can see in the possible cone cells on the left, there doesn't seem to be
a clustering by any of the experimental variables.

```{r smart-dropseq-markers-gfp}
cnames = colnames(cone_rod_smartseq)
cnames = gsub(".counts", "", cnames)
cnames = gsub("X", "", cnames)
cnames = gsub(".", "_", cnames, fixed=TRUE)
colnames(cone_rod_smartseq) = cnames
pheatmap(cone_rod_smartseq, fontsize=6, annotation_row=anno_df,
         cluster_rows=FALSE, annotation_colors=ann_colors, show_colnames=FALSE,
         annotation=smartseq_summary[, c("Mapped", "lgfp", "rescue", "location_info")])
```

## scrbseq-umi vs non-umi counts
```{r scrbseq-umi-vs-nonumi}
scrbseq_umi_fn = "/Volumes/Clotho/Users/rory/cache/wu-retina-singlecell/01-scrbseq/Cepko_Trimarchi_buffer.unq.refseq.umi.dat"
scrbseq_umi = read.table(scrbseq_umi_fn, header=TRUE)
colnames(scrbseq_umi) = gsub("T384s", "", colnames(scrbseq_umi))
scrbseq_total_fn = "/Volumes/Clotho/Users/rory/cache/wu-retina-singlecell/01-scrbseq/Cepko_Trimarchi_buffer.unq.refseq.total.dat"
scrbseq_total = read.table(scrbseq_total_fn, header=TRUE)
colnames(scrbseq_total) = gsub("T384s", "", colnames(scrbseq_total))

umi_counts = colSums(scrbseq_umi)
total_counts = colSums(scrbseq_total)

qplot(umi_counts/total_counts) +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    xlab("(UMI counts in sample) / (total counts in sample)")
```

There are 12,982,672 total alignments in genes but only 863,176 of them are
unique after taking into account the UMI. That indicates these libraries are
likely to be non-complex. Some cells are better than others but most samples
it is about 10-1.

SCRB-seq just grabs the tail end of the transcript; there might be degradation of
the RNA happening which is causing the libraries to be not complex. We can
see that by looking at the 5'->3' bias.

## 5'->3' bias in the pilot plate and SMART-seq
The pilot experiment has a much higher 5'-3' bias than the SMART-seq data. This
bias means more reads are mapped to the 5' end than the 3' end of the data. I'm
not sure what is different between the library preparation methods; sometimes
if a stranded protocol is run this can look like that. Other times it can be
a sign of degradation of the RNA, though usually that looks like a bias towards
the 3' end not the 5' end.

```{r smartseq-pilot-bias}
a = data.frame(duplication=summarydata$Duplication.Rate.of.Mapped,
               bias=summarydata$X5.3.bias,
               experiment="pilot-plate")
b = data.frame(duplication=smartseq_summary$Duplication.Rate.of.Mapped,
               bias=smartseq_summary$X5.3.bias,
               experiment="smartseq")
d = rbind(a, b)

ggplot(d, aes(duplication, bias, color=experiment)) + geom_point() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90))
```

## comparing the pilot plate run paired and unpaired

There are some differences between the paired and unpaired samples, but for
the most part they are similar with correlation values > 0.98.

```{r paired-vs-unpaired}
paired = read.table("/Volumes/Clotho/Users/rory/cache/wu-retina-singlecell/pilot-plate-paired/combined.counts", header=TRUE, row.names="id")
cnames = colnames(paired)
cnames = gsub("_R.counts", "", cnames)
cnames = gsub("X", "", cnames)
cnames = gsub(".", "_", cnames, fixed=TRUE)
colnames(paired) <- cnames
paired <- paired[, cnames[order(cnames)]]

qplot(paired[,1], counts[,1])
qplot(paired[,2], counts[,2])
```


## wrapup
I don't have very many recommendations at this point; we're trying to solve
which technology works better and also look at three or four different experiments
at once, it makes it really hard to say anything definitive.

Any way I slice these datasets, we can't seem to pull out anything that
makes sense.

If this was my experiment I'd try to make it a lot simpler; we're having problems
now even figuring out what cells are being captured. No set of markers that
we've looked at seem to separate out the cones and rods.
